
#define ANIM_CAT_FRAME_DURATION 75 // how long each frame lasts in ms
#define ANIM_CAT_SIZE 144 //single image! number of bytes in array, minimize for adequate firmware size, max is 1024
#define BONK_FRAMES 2
#define KEYS_SIZE 100 // the number of keys stored in the array that tracks keypresses; how many keys are on the board?
#define restBONK_TIMEOUT 1000
#define restBONK_FRAMES 1

enum ANIM_CAT_states
{
    restBONK,
    rdyBONK,
    BONK
};
uint8_t ANIM_CAT_state = rdyBONK;
uint32_t ANIM_CAT_timer = 0;
uint8_t current_BONK_frame = 0;
uint32_t restBONK_timeout_timer = 0;
uint32_t current_restBONK_frame = 0;

struct pair_int_int
{
    uint8_t first;
    uint8_t second;
};
struct pair_int_int pressed_keys[KEYS_SIZE];
struct pair_int_int pressed_keys_prev[KEYS_SIZE];
uint8_t pressed_keys_index = 0;

bool key_down = 0;
char wpm[42];


static const char PROGMEM restBONK_minimal[][ANIM_CAT_SIZE] =
{
    {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x20, 
    0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x40, 0x40, 0x40, 0x00, 0x80, 0x40, 0x20, 0x18, 0x04, 0x02, 0x01, 0x31, 0x00, 0x40, 0x40, 0x80, 
    0x81, 0x82, 0x02, 0x02, 0x84, 0x04, 0x04, 0x08, 0x08, 0x10, 0x10, 0x08, 0x88, 0x70, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x03, 0x04, 0x04, 0x02, 0x01, 0x00, 0x02, 0x02, 0x02, 0x02, 0x04, 0x04, 0x04, 
    0x08, 0x88, 0x48, 0x50, 0x21, 0x90, 0x80, 0x40, 0x40, 0x20, 0x20, 0x40, 0x41, 0x86, 0xf8, 0x80, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

//use vertical
    }
};



static const char PROGMEM rdyBONK_minimal[][ANIM_CAT_SIZE] =
{
    {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x40, 0x20, 0xe0, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x40, 0x40, 0x70, 0xa8, 0x88, 0x90, 0xa0, 0x58, 0x04, 0x02, 0x01, 0x30, 0x00, 0x40, 0x40, 0x80, 
    0x81, 0x82, 0x02, 0x02, 0x84, 0x04, 0x84, 0x48, 0x48, 0x90, 0x08, 0x08, 0x84, 0x78, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x04, 0x04, 0x04, 
    0x08, 0x08, 0x08, 0x08, 0x11, 0x10, 0x17, 0x31, 0x20, 0x23, 0x44, 0x40, 0x41, 0x86, 0xf8, 0x80, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
//use vertical
    }
};


static const char PROGMEM BONK_minimal[BONK_FRAMES][ANIM_CAT_SIZE] =
{
    {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x20, 
0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x40, 0x40, 0x40, 0x00, 0x80, 0x40, 0x20, 0x18, 0x04, 0x02, 0x01, 0x31, 0x00, 0x40, 0x40, 0x80, 
0x81, 0x82, 0x02, 0x02, 0x84, 0x04, 0x84, 0x48, 0x48, 0x90, 0x10, 0x08, 0x88, 0x70, 0x00, 0x00, 
0xc2, 0xe0, 0x30, 0x03, 0x04, 0xe4, 0x82, 0x01, 0x00, 0x02, 0x02, 0x02, 0x02, 0x04, 0x04, 0x04, 
0x08, 0x08, 0x08, 0x08, 0x11, 0x10, 0x17, 0x31, 0x20, 0x23, 0x44, 0x40, 0x41, 0x86, 0xf8, 0x80, 
0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    },
    {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x40, 0x20, 0xe0, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x40, 0x40, 0x70, 0xa8, 0x88, 0x90, 0xa0, 0x58, 0x04, 0x02, 0x01, 0x30, 0x00, 0x40, 0x40, 0x80, 
0x81, 0x82, 0x02, 0x02, 0x84, 0x04, 0x04, 0x08, 0x08, 0x10, 0x08, 0x08, 0xc4, 0x38, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x42, 0x62, 0xc2, 0xc2, 0x84, 0x84, 0x04, 
0x08, 0x88, 0x48, 0x50, 0x21, 0x90, 0x80, 0x40, 0x40, 0x20, 0x20, 0x40, 0x41, 0x86, 0xf8, 0x80, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x18, 0x1c, 0x0c, 0x04, 0x02, 
0x02, 0x00, 0x79, 0xe1, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    }
};

bool detect_key_down(void)
{
    // store the previous cycle's cache
    for (uint8_t i = 0; i < KEYS_SIZE; ++i)
    {
        pressed_keys_prev[i].first = pressed_keys[i].first;
        pressed_keys_prev[i].second = pressed_keys[i].second;
    }

    // fill cache with currently pressed keys
    pressed_keys_index = 0;
    for (uint8_t x = 0; x < MATRIX_ROWS; x++)
    {
        for (uint8_t y = 0; y < MATRIX_COLS; y++)
        {
            // is this key is currently down?
            if (((matrix_get_row(x) & (1 << y)) > 0))
            {
                pressed_keys[pressed_keys_index].first = x+1; // adding 1 to the row/col so that we can use 0 as a null-check
                pressed_keys[pressed_keys_index].second = y+1;
            }
            else
            {
                pressed_keys[pressed_keys_index].first = 0;
                pressed_keys[pressed_keys_index].second = 0;
            }
            pressed_keys_index++;
        }
    }

    // check for a new key down compared to last cycle
    for (uint8_t i = 0; i < KEYS_SIZE; ++i)
    {
        if (pressed_keys[i].first && pressed_keys[i].second && !pressed_keys_prev[i].first && !pressed_keys_prev[i].second)
        {
            return true;
        }
    }
    return false;
}

void eval_ANIM_CAT_state(void)
{
    key_down = detect_key_down();

    switch (ANIM_CAT_state)
    {
        case restBONK:

            if (key_down) // rest to bonk
            {
                ANIM_CAT_state = BONK;
            }
            
            break;

        case rdyBONK:

            if (key_down) // rdyBONK to BONK
            {
             current_BONK_frame = (current_BONK_frame + 1) % BONK_FRAMES;
                ANIM_CAT_state = BONK;
            }
            else if (timer_elapsed32(restBONK_timeout_timer) >= restBONK_TIMEOUT) // Prep to Idle
            {
                ANIM_CAT_state = restBONK;
                current_restBONK_frame = 0;
                current_BONK_frame = (current_BONK_frame + 1) % BONK_FRAMES;
            }
            else{
                ANIM_CAT_state = rdyBONK;
            }
            break;

        case BONK:
               
            if (!key_down) // BONK to rdyBONK
            {
                ANIM_CAT_state = rdyBONK;
                restBONK_timeout_timer = timer_read32();
                 
            }
            break;

        default:
            break;
    }
}

static void draw_bongo(bool minimal)
{
    eval_ANIM_CAT_state();

    oled_set_cursor(0, 12);

    switch (ANIM_CAT_state)
    {
            case restBONK:
                oled_write_raw_P(restBONK_minimal[0], ANIM_CAT_SIZE);

            if (timer_elapsed32(ANIM_CAT_timer) > ANIM_CAT_FRAME_DURATION)
            {
                ANIM_CAT_timer = timer_read32();
            }
            break;


        case rdyBONK:
                oled_write_raw_P(rdyBONK_minimal[0], ANIM_CAT_SIZE);
            break;

        case BONK:

                oled_write_raw_P(BONK_minimal[abs((BONK_FRAMES - 1) - current_BONK_frame)], ANIM_CAT_SIZE);

                    
         break;

    default:
    break;
    }
}



