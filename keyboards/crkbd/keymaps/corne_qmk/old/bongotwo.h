// #define ANIM_FRAME_DURATION 100 // how long each frame lasts in ms
#define ANIM_SIZE 431 // number of bytes in array, minimize for adequate firmware size, max is 1024
#define KEYS_SIZE 42 // the number of keys stored in the array that tracks keypresses; how many keys are on the board?


enum anim_states
{
    Prep,
    Tap
};
uint8_t anim_state = Prep;
uint32_t anim_timer = 0;
uint8_t current_tap_frame = 0;

struct pair_int_int
{
    uint8_t first;
    uint8_t second;
};
struct pair_int_int pressed_keys[KEYS_SIZE];
struct pair_int_int pressed_keys_prev[KEYS_SIZE];
uint8_t pressed_keys_index = 0;

bool key_down = 0;



static const char PROGMEM prep_minimal[][ANIM_SIZE] =
{
    {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x40, 0x20, 0xe0, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x40, 0x40, 0x70, 0xa8, 0x88, 0x90, 0xa0, 0x58, 0x04, 0x02, 0x01, 0x30, 0x00, 0x40, 0x40, 0x80, 
0x81, 0x82, 0x02, 0x02, 0x84, 0x04, 0x84, 0x48, 0x48, 0x90, 0x08, 0x08, 0x84, 0x78, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x04, 0x04, 0x04, 
0x08, 0x08, 0x08, 0x08, 0x11, 0x10, 0x17, 0x31, 0x20, 0x23, 0x44, 0x40, 0x41, 0x86, 0xf8, 0x80, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
//use vertical
    }
};

static const char PROGMEM tap_minimal[][ANIM_SIZE] =
{
    {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x20, 
0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x40, 0x40, 0x40, 0x00, 0x80, 0x40, 0x20, 0x18, 0x04, 0x02, 0x01, 0x31, 0x00, 0x40, 0x40, 0x80, 
0x81, 0x82, 0x02, 0x02, 0x84, 0x04, 0x04, 0x08, 0x08, 0x10, 0x10, 0x08, 0x88, 0x70, 0x00, 0x00, 
0x42, 0xe0, 0x30, 0x03, 0x04, 0xe4, 0x82, 0x01, 0x00, 0x02, 0x02, 0x42, 0xc2, 0x84, 0x84, 0x04, 
0x08, 0x88, 0x48, 0x50, 0x21, 0x90, 0x80, 0x40, 0x40, 0x20, 0x20, 0x40, 0x41, 0x86, 0xf8, 0x80, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x0c, 0x04, 0x02, 
0x00, 0x00, 0x01, 0x0d, 0x39, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    }
};

bool detect_key_down(void)
{
    // store the previous cycle's cache
    for (uint8_t i = 0; i < KEYS_SIZE; ++i)
    {
        pressed_keys_prev[i].first = pressed_keys[i].first;
        pressed_keys_prev[i].second = pressed_keys[i].second;
    }

    // fill cache with currently pressed keys
    pressed_keys_index = 0;
    for (uint8_t x = 0; x < MATRIX_ROWS; x++)
    {
        for (uint8_t y = 0; y < MATRIX_COLS; y++)
        {
            // is this key is currently down?
            if (((matrix_get_row(x) & (1 << y)) > 0))
            {
                pressed_keys[pressed_keys_index].first = x+1; // adding 1 to the row/col so that we can use 0 as a null-check
                pressed_keys[pressed_keys_index].second = y+1;
            }
            else
            {
                pressed_keys[pressed_keys_index].first = 0;
                pressed_keys[pressed_keys_index].second = 0;
            }
            pressed_keys_index++;
        }
    }

    // check for a new key down compared to last cycle
    for (uint8_t i = 0; i < KEYS_SIZE; ++i)
    {
        if (pressed_keys[i].first && pressed_keys[i].second && !pressed_keys_prev[i].first && !pressed_keys_prev[i].second)
        {
            return true;
        }
    }
    return false;
}

void eval_anim_state(void)
{
    key_down = detect_key_down();

    switch (anim_state)
    {
        
        case Prep:
            if (key_down) // Prep to Tap
            {
                anim_state = Tap;
            }
            
            break;

        case Tap:
            if (!key_down) // Tap to Prep
            {
                anim_state = Prep;
            }
            break;

        default:
            break;
    }
}

static void draw_bongo(bool minimal)
{
    eval_anim_state();

    oled_set_cursor(0, 11);

    switch (anim_state)
    {
        case Prep:
                oled_write_raw_P(prep_minimal[0], ANIM_SIZE);
            break;

        case Tap:
                oled_write_raw_P(tap_minimal[0], ANIM_SIZE);

                break;
    }
}











/////////////////////////////////////////////////

#define TAKO_FRAME_DURATION 100 // how long each frame lasts in ms
#define TAKO_SIZE 576 // number of bytes in array, minimize for adequate firmware size, max is 1024
#define TAKO_FRAMES 4
#define TAKO_TIMEOUT 5000

uint32_t tako_timer = 0;
uint8_t current_tako_frame = 0;
uint32_t tako_sleep = 0;


                                    
static const char PROGMEM tako_jump[TAKO_FRAMES][TAKO_SIZE] = 
{
{
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x70, 0x88, 0x08, 0x10, 0x20, 0x2c, 0x1a, 0x12, 0x12, 0x09, 0x09, 0x09, 
0x09, 0x09, 0x09, 0x12, 0x12, 0x1a, 0x2c, 0x20, 0x10, 0x08, 0x88, 0x70, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xc0, 0x38, 0x07, 0x10, 0x00, 0x14, 0x04, 0x02, 0x12, 0x20, 0x20, 0x10, 
0x20, 0x20, 0x12, 0x02, 0x04, 0x14, 0x00, 0x10, 0x00, 0x07, 0x38, 0xc0, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x03, 0x04, 0x0c, 0x0c, 0x0c, 0x08, 0x10, 0x10, 0x10, 0x10, 0x08, 0x18, 0x1c, 
0x1c, 0x1c, 0x08, 0x10, 0x10, 0x10, 0x10, 0x08, 0x08, 0x0c, 0x0c, 0x08, 0x07, 0x00, 0x00, 0x00
},
{
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x40, 0x40, 0x40, 
0x40, 0x40, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x60, 0x90, 0x10, 0x90, 0x08, 0x0b, 0x06, 0x04, 0x04, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x04, 0x04, 0x06, 0x0b, 0x08, 0x08, 0x90, 0x10, 0x90, 0x60, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x80, 0x60, 0x1c, 0x03, 0x10, 0x00, 0x12, 0x02, 0x01, 0x09, 0x10, 0x10, 0x08, 
0x10, 0x10, 0x09, 0x01, 0x02, 0x12, 0x00, 0x10, 0x00, 0x03, 0x3c, 0xe0, 0x80, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0x02, 0x06, 0x0c, 0x0c, 0x08, 0x0c, 0x0c, 0x1e, 0x1e, 0x1e, 0x0c, 0x08, 
0x10, 0x10, 0x08, 0x0c, 0x1e, 0x1e, 0x0c, 0x08, 0x08, 0x0c, 0x06, 0x06, 0x03, 0x00, 0x00, 0x00
},
{
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x40, 0xa0, 0xa0, 0xa0, 
0xa0, 0xa0, 0x40, 0x40, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0xc0, 0x30, 0x88, 0x04, 0x02, 0x42, 0x41, 0x21, 0x21, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x21, 0x21, 0x41, 0x42, 0x02, 0x04, 0x88, 0x30, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0xf9, 0x07, 0x00, 0x80, 0x82, 0x80, 0x00, 0x01, 0x02, 0x02, 0x81, 
0x82, 0x82, 0x81, 0x00, 0x00, 0x02, 0x00, 0x82, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x01, 0x03, 0x03, 0x03, 0x01, 0x02, 0x02, 0x01, 0x00, 
0x01, 0x01, 0x03, 0x03, 0x02, 0x01, 0x01, 0x03, 0x03, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00
},
{
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x40, 0x40, 0x40, 0x40, 
0x40, 0x40, 0x40, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x38, 0x48, 0x88, 0x48, 0x04, 0x07, 0x06, 0x84, 0x82, 0x02, 0x02, 0x02, 
0x02, 0x02, 0x82, 0x86, 0x06, 0x07, 0x04, 0x48, 0x88, 0x48, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0xc0, 0x20, 0x10, 0x0e, 0x01, 0x08, 0x00, 0x09, 0x01, 0x00, 0x04, 0x08, 0x08, 0x04, 
0x08, 0x08, 0x04, 0x00, 0x01, 0x09, 0x00, 0x08, 0x01, 0x0e, 0x30, 0x40, 0x80, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x01, 0x02, 0x04, 0x04, 0x0e, 0x0f, 0x06, 0x04, 0x08, 0x08, 0x0c, 0x0e, 0x0f, 
0x06, 0x04, 0x08, 0x08, 0x08, 0x04, 0x06, 0x0f, 0x0e, 0x0c, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00
}
};





static void draw_tako(void)

{

    oled_set_cursor(0, 10);// sets cursor to (row, column) using charactar spacing (5 rows on 128x32 screen, anything more will overflow back to the top)
   
   if (timer_elapsed32(tako_sleep) < TAKO_TIMEOUT) {
    oled_write_raw_P(tako_jump[abs((TAKO_FRAMES - 1) - current_tako_frame)], TAKO_SIZE);
                
        if (timer_elapsed32(tako_timer) > TAKO_FRAME_DURATION) {
        current_tako_frame = (current_tako_frame + 1) % TAKO_FRAMES;
        tako_timer = timer_read32();
        }
       
     }
    }



static void restart_tako(void)
   {  
    if (get_current_wpm()!= 000) {

         if (timer_elapsed32(tako_sleep) > TAKO_TIMEOUT) {
          tako_sleep = timer_read32();
            draw_tako();
            }
            else  { 
                draw_tako(); 
            }
        }
        else 
            if (timer_elapsed32(tako_sleep) > TAKO_TIMEOUT) {

                oled_write_raw_P(tako_jump[1], TAKO_SIZE);
            }
            else 

            {
                draw_tako(); {
              }
}
}



